package generators

var templates = map[string]string{
	"callbacks": `
{{ range .Objects }}
type {{ initialCap .Name }}Callbacks interface {
{{ if .OperProperties | len }}
  {{ initialCap .Name }}GetOper({{ .Name }} *{{ initialCap .Name }}Inspect) error {{ end }}
{{ if .CfgProperties | len }}
  {{ initialCap .Name }}Create({{ .Name }} *{{ initialCap .Name }}) error
  {{ initialCap .Name }}Update({{ .Name }}, params *{{ initialCap .Name }}) error
  {{ initialCap .Name }}Delete({{ .Name }} *{{ initialCap .Name }}) error {{ end }}
}
{{ end }}

type CallbackHandlers struct {
  {{ range .Objects }} {{ initialCap .Name }}Cb {{ initialCap .Name }}Callbacks
  {{ end }}
}

var objCallbackHandler CallbackHandlers
  `,
	"clientHdr": `
// {{.Name}}Client.go
// This file is auto generated by modelgen tool
// Do not edit this file manually

// package client provides contiv REST client implementation.
//
// Concepts and Terminology:
//
// Tenant : 
// Tenants provides namespace isolation for networks. It is the toplevel object where networks
// and policies are defiend. 
// A tenant can have many networks, each with its own subnet address, among other information. 
// A user can create networks with arbtrary subnet addresses within a tenant namespace, 
// possibly reusing subnet IP addresses in other tenants. This provides complete freedom to a 
// tenant user to specify the network names and their subnets within a tenant.
//
// Network:
// Network is an IPv4 or IPv6 subnet that may be provided with a default gateway. 
// For example, a network can map to a subnet 10.1.1.0/24 that has a default gateway of 10.1.1.1.
//
// Policies:
// A policy describes an operational behavior on a group of containers. 
// The operational behavior can be enforcement, allocation, prioritation, traffic redirection, 
// stats collection, or other action on the group on which the policy is applied. For example, 
// an inbound security policy on a database tier can specify the allowed ports on the containers 
// belonging to the group.
// 
// EndpointGroups:
// Endpoint group (or an application group) identifies a policy domain for a container or a pod. 
// The grouping is an arbitrary collection of containers that share a specific application domain, 
// for example all production,frontend containers, or backup,long-running containers. 
// This association is often done by specifying label in kubernetes pod spec
//
// contiv object model is shown here https://github.com/contiv/modelgen/blob/master/docs/contivModel.png
//
// Example:
//
//package main
//
//import (
//    "log"
//    "github.com/contiv/contivModel/client"
//)
//
//func main() {
//    cl, err := client.NewContivClient("localhost:9999")
//    if err != nil {
//        log.Fatal(err)
//    }
//
//    // Define a policy
//    policy := client.Policy{
//        TenantName: "tenant1",
//        PolicyName: "policy",
//    }
//
//    // Create policy
//    err = cl.PostPolicy(policy)
//    if err != nil {
//        log.Errorf("Policy Creation failed. Err: %v", err)
//    }
//}
package client

import (
	"bytes"
	"encoding/json"
	"errors"
	"io/ioutil"
	"net/http"

	log "github.com/Sirupsen/logrus"
)

// Link is a one way relattion between two objects
type Link struct {
	ObjType string ` + "`" + `json:"type,omitempty"` + "`" + `
	ObjKey  string ` + "`" + `json:"key,omitempty"` + "`" + `
}

func httpGet(url string, jdata interface{}) error {

	r, err := http.Get(url)
	if err != nil {
		return err
	}
	defer r.Body.Close()

	switch {
	case r.StatusCode == int(404):
		return errors.New("Page not found!")
	case r.StatusCode == int(403):
		return errors.New("Access denied!")
	case r.StatusCode == int(500):
		response, err := ioutil.ReadAll(r.Body)
		if err != nil {
			return err
		}

		return errors.New(string(response))

	case r.StatusCode != int(200):
		log.Debugf("GET Status '%s' status code %d \n", r.Status, r.StatusCode)
		return errors.New(r.Status)
	}

	response, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return err
	}

	if err := json.Unmarshal(response, jdata); err != nil {
		return err
	}

	return nil
}

func httpDelete(url string) error {

	req, err := http.NewRequest("DELETE", url, nil)

	r, err := http.DefaultClient.Do(req)
	if err != nil {
		panic(err)
	}
	defer r.Body.Close()

	// body, _ := ioutil.ReadAll(r.Body)

	switch {
	case r.StatusCode == int(404):
		// return errors.New("Page not found!")
		return nil
	case r.StatusCode == int(403):
		return errors.New("Access denied!")
	case r.StatusCode == int(500):
		response, err := ioutil.ReadAll(r.Body)
		if err != nil {
			return err
		}

		return errors.New(string(response))

	case r.StatusCode != int(200):
		log.Debugf("DELETE Status '%s' status code %d \n", r.Status, r.StatusCode)
		return errors.New(r.Status)
	}

	return nil
}

func httpPost(url string, jdata interface{}) error {
	buf, err := json.Marshal(jdata)
	if err != nil {
		return err
	}

	body := bytes.NewBuffer(buf)
	r, err := http.Post(url, "application/json", body)
	if err != nil {
		return err
	}
	defer r.Body.Close()

	switch {
	case r.StatusCode == int(404):
		return errors.New("Page not found!")
	case r.StatusCode == int(403):
		return errors.New("Access denied!")
	case r.StatusCode == int(500):
		response, err := ioutil.ReadAll(r.Body)
		if err != nil {
			return err
		}

		return errors.New(string(response))

	case r.StatusCode != int(200):
		log.Debugf("POST Status '%s' status code %d \n", r.Status, r.StatusCode)
		return errors.New(r.Status)
	}

	response, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return err
	}
	log.Debugf(string(response))

	return nil
}

// ContivClient has the contiv model client instance
type ContivClient struct {
	baseURL string
}

// NewContivClient creates a new client instance
func NewContivClient(baseURL string) (*ContivClient, error) {
	client := ContivClient{
		baseURL: baseURL,
	}

	return &client, nil
}
  `,
	"clientObj": `
{{ if .CfgProperties | len }}
// {{ initialCap .Name }}Post posts the {{.Name}} object
func (c *ContivClient) {{ initialCap .Name }}Post(obj *{{ initialCap .Name }}) error {
	// build key and URL
	keyStr := {{range $index, $element := .Key}}{{if eq 0 $index }}obj.{{initialCap .}}{{else}} + ":" + obj.{{initialCap .}}{{end}}{{end}}
	url := c.baseURL + "/api/{{.Version}}/{{ .Name }}s/" + keyStr + "/"

	// http post the object
	err := httpPost(url, obj)
	if err != nil {
		log.Debugf("Error creating {{ .Name }} %+v. Err: %v", obj, err)
		return err
	}

	return nil
}

// {{ initialCap .Name }}List lists all {{ .Name }} objects
func (c *ContivClient) {{ initialCap .Name }}List() (*[]*{{ initialCap .Name }}, error) {
	// build key and URL
	url := c.baseURL + "/api/{{.Version}}/{{ .Name }}s/"

	// http get the object
	var objList []*{{ initialCap .Name }}
	err := httpGet(url, &objList)
	if err != nil {
		log.Debugf("Error getting {{ .Name }}s. Err: %v", err)
		return nil, err
	}

	return &objList, nil
}

// {{ initialCap .Name }}Get gets the {{ .Name }} object
func (c *ContivClient) {{ initialCap .Name }}Get({{range $index, $element := .Key}}{{if eq 0 $index }}{{ .}} string{{else}}, {{ .}} string{{end}}{{end}}) (*{{ initialCap .Name }}, error) {
	// build key and URL
	keyStr := {{range $index, $element := .Key}}{{if eq 0 $index }}{{ .}}{{else}} + ":" + {{ .}}{{end}}{{end}}
	url := c.baseURL + "/api/{{.Version}}/{{ .Name }}s/" + keyStr + "/"

	// http get the object
	var obj {{ initialCap .Name }}
	err := httpGet(url, &obj)
	if err != nil {
		log.Debugf("Error getting {{ .Name }} %+v. Err: %v", keyStr, err)
		return nil, err
	}

	return &obj, nil
}

// {{ initialCap .Name }}Delete deletes the {{ .Name }} object
func (c *ContivClient) {{ initialCap .Name }}Delete({{range $index, $element := .Key}}{{if eq 0 $index }}{{ .}} string{{else}}, {{ .}} string{{end}}{{end}}) error {
	// build key and URL
	keyStr := {{range $index, $element := .Key}}{{if eq 0 $index }}{{ .}}{{else}} + ":" + {{ .}}{{end}}{{end}}
	url := c.baseURL + "/api/{{.Version}}/{{ .Name }}s/" + keyStr + "/"

	// http get the object
	err := httpDelete(url)
	if err != nil {
		log.Debugf("Error deleting {{ .Name }} %s. Err: %v", keyStr, err)
		return err
	}

	return nil
}
{{ end }}

// {{ initialCap .Name }}Inspect gets the {{ .Name }}Inspect object
func (c *ContivClient) {{ initialCap .Name }}Inspect({{range $index, $element := .Key}}{{if eq 0 $index }}{{ .}} string{{else}}, {{ .}} string{{end}}{{end}}) (*{{ initialCap .Name }}Inspect, error) {
	// build key and URL
	keyStr := {{range $index, $element := .Key}}{{if eq 0 $index }}{{ .}}{{else}} + ":" + {{ .}}{{end}}{{end}}
	url := c.baseURL + "/api/{{.Version}}/inspect/{{ .Name }}s/" + keyStr + "/"

	// http get the object
	var obj {{ initialCap .Name }}Inspect
	err := httpGet(url, &obj)
	if err != nil {
		log.Debugf("Error getting {{ .Name }} %+v. Err: %v", keyStr, err)
		return nil, err
	}

	return &obj, nil
}
  `,
	"clientstruct": `
{{ if .CfgProperties | len }}
// {{ initialCap .Name }} object
type {{ initialCap .Name }} struct {
	// every object has a key
	Key		string		` + "`" + `json:"key,omitempty"` + "`" + `

  {{ range .CfgProperties }} {{ .GenerateGoStructs }} {{ end }}

  {{ if .LinkSets | len }}
  // add link-sets and links
	LinkSets	{{ initialCap .Name }}LinkSets		` + "`" + `json:"link-sets,omitempty"` + "`" + `
  {{ end }} {{ if .Links | len }} Links	{{ initialCap .Name }}Links		` + "`" + `json:"links,omitempty"` + "`" + `
  {{ end }}
}

{{ if .LinkSets | len }}
// {{ initialCap .Name }}LinkSets list of internal links
type {{ initialCap .Name }}LinkSets struct {
  {{ range .LinkSets }} {{ initialCap .Name }}	map[string]Link		` + "`" + `json:"{{ .Name }},omitempty"` + "`" + `
  {{end}}
}
{{ end }}

{{ if .Links | len }}
// {{ initialCap .Name }}Links internal links to other object
type {{ initialCap .Name }}Links struct {
  {{ range .Links }} {{ initialCap .Name }} Link	` + "`" + `json:"{{ .Name }},omitempty"` + "`" + `
  {{ end }}
}
{{ end }}
{{ end }}

{{ if .OperProperties | len }}
// {{ initialCap .Name }}Oper runtime operations
type {{ initialCap .Name }}Oper struct {
  {{ range .OperProperties }} {{ .GenerateGoStructs }} {{ end }}

  {{ if .OperLinkSets | len }}
	// add link-sets and links
	LinkSets	{{ initialCap .Name }}LinkSets		` + "`" + `json:"link-sets,omitempty"` + "`" + `
  {{ end }} {{ if .OperLinks | len }} OperLinks	{{ initialCap .Name }}Links		` + "`" + `json:"links,omitempty"` + "`" + `
  {{ end }}
}
{{ end }}

// {{ initialCap .Name }}Inspect inspect information
type {{ initialCap .Name }}Inspect struct {
	{{ if .CfgProperties }}
	Config		{{ initialCap .Name }}
	{{ end }}

	{{ if .OperProperties }}
	Oper		{{ initialCap .Name }}Oper
	{{ end }}
}

  `,
	"gostructs": `
type Collections struct {
  {{ range .Objects }}
  {{ if .CfgProperties | len }}
  {{ .Name }}Mutex sync.Mutex
  {{ .Name }}s map[string]*{{ initialCap .Name }}
  {{ end }}
  {{ end }}
}

var collections Collections
  `,
	"hdr": `
// {{.Name}}.go
// This file is auto generated by modelgen tool
// Do not edit this file manually

package {{.Name}}

import (
	"errors"
	"regexp"
	"net/http"
	"encoding/json"
  "sync"
	"github.com/contiv/objdb/modeldb"
	"github.com/gorilla/mux"
	log "github.com/Sirupsen/logrus"
)

type HttpApiFunc func(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error)
  `,
	"init": `
func Init() {
  {{ range .Objects }}
  {{ if .CfgProperties | len }}
  collections.{{ .Name }}s = make(map[string]*{{ initialCap .Name }})
  {{ end }}

  {{ end }}
  {{ range .Objects }} {{ if .CfgProperties | len }} restore{{ initialCap .Name}}() {{ end }}
  {{ end }}
}
  `,
	"jsView": `
var {{ initialCap .Name }}SummaryView = React.createClass({
  	render: function() {
		var self = this

		// Walk thru all objects
		var {{ .Name }}ListView = self.props.{{ .Name }}s.map(function({{ .Name }}){
			return (
				<ModalTrigger modal={<{{ initialCap .Name }}ModalView {{ .Name }}={ {{ .Name }} }/>}>
					<tr key={ {{ .Name }}.key } className="info">
						{{ $objName := .Name }}
						{{range $element := .CfgProperties }} {{if eq $element.ShowSummary true}}
						<td>{ {{ $objName }}.{{ $element.Name }} }</td>
						{{end}}{{end}}
					</tr>
				</ModalTrigger>
			);
		});

		return (
        <div>
			<Table hover>
				<thead>
					<tr>
					{{ $objName := .Name }}
					{{range $element := .CfgProperties }} {{if eq $element.ShowSummary true}}
						<th> {{ $element.Title }} </th> {{end}}{{end}}
					</tr>
				</thead>
				<tbody>
            		{ {{ .Name }}ListView }
				</tbody>
			</Table>
        </div>
    	);
	}
});

var {{ initialCap .Name }}ModalView = React.createClass({
	render() {
		var obj = this.props.{{.Name}}
	    return (
	      <Modal {...this.props} bsStyle='primary' bsSize='large' title='{{ initialCap .Name }}' animation={false}>
	        <div className='modal-body' style={ {margin: '5%',} }>
			{{ $objName := .Name }}
			{{range $element := .CfgProperties }}
				<Input type='text' label='{{ $element.Title }}' ref='{{ $element.Name }}' defaultValue={obj.{{$element.Name}}} placeholder='{{ $element.Title }}' />
			{{end}}
			</div>
	        <div className='modal-footer'>
				<Button onClick={this.props.onRequestHide}>Close</Button>
	        </div>
	      </Modal>
	    );
  	}
});

module.exports.{{ initialCap .Name }}SummaryView = {{ initialCap .Name }}SummaryView
module.exports.{{ initialCap .Name }}ModalView = {{ initialCap .Name }}ModalView
  `,
	"objcount": `
{{ range .Objects }} {{ if .CfgProperties | len }}
func Get{{ initialCap .Name }}Count() int {
	return len(collections.{{ .Name }}s)
}
{{ end }}
{{ end }}
  `,
	"objstruct": `
{{ if .CfgProperties | len }}
type {{ initialCap .Name }} struct {
	// every object has a key
	Key		string		` + "`" + `json:"key,omitempty"` + "`" + `

  {{ range .CfgProperties }} {{ .GenerateGoStructs }} {{ end }}

  {{ if .LinkSets | len }}
	// add link-sets and links
	LinkSets	{{ initialCap .Name }}LinkSets		` + "`" + `json:"link-sets,omitempty"` + "`" + `
  {{ end }} {{ if .Links | len }} Links	{{ initialCap .Name }}Links		` + "`" + `json:"links,omitempty"` + "`" + `
  {{ end }}
}

{{ if .LinkSets | len }}
type {{ initialCap .Name }}LinkSets struct {
  {{ range .LinkSets }}
  {{ initialCap .Name }}	map[string]modeldb.Link		` + "`" + `json:"{{ .Name }},omitempty"` + "`" + `
  {{end}}
}
{{ end }}

{{ if .Links | len }}
type {{ initialCap .Name }}Links struct {
  {{ range .Links }} 
  {{ initialCap .Name }} modeldb.Link	` + "`" + `json:"{{ .Name }},omitempty"` + "`" + `
  {{ end }}
}
{{ end }}
{{ end }}

{{ if .OperProperties | len }}
type {{ initialCap .Name }}Oper struct {
{{ if .CfgProperties | len }}{{ else }}
	// oper object key (present for oper only objects)
	Key		string		` + "`" + `json:"key,omitempty"` + "`" + ` {{ end }}
  {{ range .OperProperties }} {{ .GenerateGoStructs }} {{ end }}

  {{ if .OperLinkSets | len }}
	// add link-sets and links
	LinkSets	{{ initialCap .Name }}LinkSets		` + "`" + `json:"link-sets,omitempty"` + "`" + `
  {{ end }} {{ if .OperLinks | len }} OperLinks	{{ initialCap .Name }}Links		` + "`" + `json:"links,omitempty"` + "`" + ` {{ end }}
}
{{ end }}

type {{ initialCap .Name }}Inspect struct {
	{{ if .CfgProperties }}
	Config		{{ initialCap .Name }}
	{{ end }}

	{{ if .OperProperties }}
	Oper		{{ initialCap .Name }}Oper
	{{ end }}
}
  `,
	"propstruct": `
{{ initialCap .Name }} {{ if eq .Type "array" }} []{{ if .CfgObject }}{{ translateCfgType .Items }}{{ else }}{{ translateOperType .Items }}{{ end }} ` + "`" + `json:"{{ .Name }},omitempty"` + "`" + `{{ else }} {{ if .CfgObject }}{{ translateCfgType .Type }}{{ else }}{{ translateOperType .Type }}{{ end}} ` + "`" + `json:"{{ .Name }},omitempty"` + "`" + ` // {{.Title}} {{ end }}
  `,
	"pyclientHdr": `
# {{.Name}} REST client

import urllib
import urllib2
import json
import argparse
import os

# Exit on error
def errorExit(str):
    print "############### Operation failed: " + str + " ###############"
    os._exit(1)

# HTTP Delete wrapper
def httpDelete(url):
    opener = urllib2.build_opener(urllib2.HTTPHandler)
    request = urllib2.Request(url)
    request.get_method = lambda: 'DELETE'
    try:
        ret = opener.open(request)
        return ret

    except urllib2.HTTPError, err:
        if err.code == 404:
            print "Page not found!"
        elif err.code == 403:
            print "Access denied!"
        else:
            print "HTTP Error response! Error code", err.code
        return "Error"
    except urllib2.URLError, err:
        print "URL error:", err.reason
        return "Error"

# HTTP POST wrapper
def httpPost(url, data):
    try:
        retData = urllib2.urlopen(url, data)
        return retData.read()
    except urllib2.HTTPError, err:
        if err.code == 404:
            print "Page not found!"
        elif err.code == 403:
            print "Access denied!"
        else:
            print "HTTP Error! Error code", err.code
        return "Error"
    except urllib2.URLError, err:
        print "URL error:", err.reason
        return "Error"

# Wrapper for HTTP get
def httpGet(url):
    try:
        retData = urllib2.urlopen(url)
        return retData.read()

    except urllib2.HTTPError, err:
        if err.code == 404:
            print "Page not found!"
        elif err.code == 403:
            print "Access denied!"
        else:
            print "HTTP Error! Error code", err.code
        return "Error"
    except urllib2.URLError, err:
        print "URL error:", err.reason
        return "Error"

# object model client
class objmodelClient:
	def __init__(self, baseUrl):
		self.baseUrl = baseUrl
  `,
	"pyclientObj": `
{{ if .CfgProperties | len }}
	# Create {{ .Name }}
	def create{{ initialCap .Name }}(self, obj):
	    postUrl = self.baseUrl + '/api/{{ .Version }}/{{ .Name }}s/' + {{range $index, $element := .Key}}{{if eq 0 $index }}obj.{{ .}} {{else}}+ ":" + obj.{{ .}} {{end}}{{end}} + '/'

	    jdata = json.dumps({ {{range $index, $element := .CfgProperties}}
			"{{ .Name}}": obj.{{.Name}}, {{end}}
	    })

	    # Post the data
	    response = httpPost(postUrl, jdata)

	    if response == "Error":
	        errorExit("{{ initialCap .Name }} create failure")

	# Delete {{ .Name }}
	def delete{{ initialCap .Name }}(self, {{range $index, $element := .Key}}{{if eq 0 $index }}{{ .}}{{else}}, {{ .}}{{end}}{{end}}):
	    # Delete {{ initialCap .Name }}
	    deleteUrl = self.baseUrl + '/api/{{ .Version }}/{{ .Name }}s/' + {{range $index, $element := .Key}}{{if eq 0 $index }}{{ .}} {{else}}+ ":" + {{ .}} {{end}}{{end}} + '/'
	    response = httpDelete(deleteUrl)

	    if response == "Error":
	        errorExit("{{ initialCap .Name }} create failure")

	# List all {{ .Name }} objects
	def list{{ initialCap .Name }}(self):
	    # Get a list of {{ .Name }} objects
	    retDate = urllib2.urlopen(self.baseUrl + '/api/{{ .Version }}/{{ .Name }}s/')
	    if retData == "Error":
	        errorExit("list {{ initialCap .Name }} failed")

	    return json.loads(retData)
{{ end }}

{{ if .OperProperties | len }}
	# Inspect {{ .Name }}
	def create{{ initialCap .Name }}(self, obj):
	    postUrl = self.baseUrl + '/api/{{ .Version }}/inspect/{{ .Name }}/' + {{range $index, $element := .Key}}{{if eq 0 $index }}obj.{{ .}} {{else}}+ ":" + obj.{{ .}} {{end}}{{end}} + '/'

	    retDate = urllib2.urlopen(postUrl)
	    if retData == "Error":
	        errorExit("list {{ initialCap .Name }} failed")

	    return json.loads(retData)
{{ end }}
  `,
	"register": `
{{ range .Objects }}
func Register{{ initialCap .Name }}Callbacks(handler {{ initialCap .Name }}Callbacks) {
  objCallbackHandler.{{ initialCap .Name }}Cb = handler
}
{{ end }}
  `,
	"routeFunc": `
// Simple Wrapper for http handlers
func makeHttpHandler(handlerFunc HttpApiFunc) http.HandlerFunc {
	// Create a closure and return an anonymous function
	return func(w http.ResponseWriter, r *http.Request) {
		// Call the handler
		resp, err := handlerFunc(w, r, mux.Vars(r))
		if err != nil {
			// Log error
			log.Errorf("Handler for %s %s returned error: %s", r.Method, r.URL, err)

			// Send HTTP response
			http.Error(w, err.Error(), http.StatusInternalServerError)
		} else {
			// Send HTTP response as Json
			err = writeJSON(w, http.StatusOK, resp)
			if err != nil {
				log.Errorf("Error generating json. Err: %v", err)
			}
		}
	}
}

// writeJSON: writes the value v to the http response stream as json with standard
// json encoding.
func writeJSON(w http.ResponseWriter, code int, v interface{}) error {
	// Set content type as json
	w.Header().Set("Content-Type", "application/json")

	// write the HTTP status code
	w.WriteHeader(code)

	// Write the Json output
	return json.NewEncoder(w).Encode(v)
}

// Add all routes for REST handlers
func AddRoutes(router *mux.Router) {
	var route, listRoute, inspectRoute string

  {{ range .Objects }}

	{{ if .CfgProperties | len }}
	// Register {{.Name}}
	route = "/api/{{.Version}}/{{.Name}}s/{key}/"
	listRoute = "/api/{{.Version}}/{{.Name}}s/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpList{{initialCap .Name}}s))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGet{{initialCap .Name}}))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreate{{initialCap .Name}}))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreate{{initialCap .Name}}))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDelete{{initialCap .Name}}))
  {{ end }}

	inspectRoute = "/api/{{.Version}}/inspect/{{.Name}}s/{key}/"
	router.Path(inspectRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpInspect{{initialCap .Name}}))

  {{ end }}
}

{{ range .Objects }}

// GET Oper REST call
func httpInspect{{ initialCap .Name }}(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	var obj {{ initialCap .Name }}Inspect
	log.Debugf("Received httpInspect{{ initialCap .Name }}: %+v", vars)

{{ if .CfgProperties | len }}
	key := vars["key"]

  collections.{{ .Name }}Mutex.Lock()
  defer collections.{{ .Name }}Mutex.Unlock()
	objConfig := collections.{{ .Name }}s[key]
	if objConfig == nil {
		log.Errorf("{{ .Name }} %s not found", key)
		return nil, errors.New("{{ .Name }} not found")
	}
	obj.Config = *objConfig
{{ else }}
	obj.Oper.Key = vars["key"]
{{ end }}

{{ if .OperProperties | len }}
	if err := GetOper{{ initialCap .Name }}(&obj); err != nil {
		log.Errorf("Get{{ initialCap .Name }} error for: %+v. Err: %v", obj, err)
		return nil, err
	}
{{ end }}

	// Return the obj
	return &obj, nil
}

{{ if .OperProperties | len }}
// Get a {{ .Name }}Oper object
func GetOper{{ initialCap .Name }}(obj *{{ initialCap .Name }}Inspect) error {
	// Check if we handle this object
	if objCallbackHandler.{{ initialCap .Name }}Cb == nil {
		log.Errorf("No callback registered for {{ .Name }} object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.{{ initialCap .Name }}Cb.{{ initialCap .Name }}GetOper(obj)
	if err != nil {
		log.Errorf("{{ initialCap .Name }}Delete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	return nil
}
{{ end }}


{{ if .CfgProperties | len }}
// LIST REST call
func httpList{{ initialCap .Name }}s(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpList{{ initialCap .Name }}s: %+v", vars)

	list := make([]*{{ initialCap .Name }}, 0)
  collections.{{ .Name }}Mutex.Lock()
  defer collections.{{ .Name }}Mutex.Unlock()
	for _, obj := range collections.{{ .Name }}s {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGet{{ initialCap .Name }}(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGet{{ initialCap .Name }}: %+v", vars)

	key := vars["key"]

  collections.{{ .Name }}Mutex.Lock()
  defer collections.{{ .Name }}Mutex.Unlock()
	obj := collections.{{ .Name }}s[key]
	if obj == nil {
		log.Errorf("{{ .Name }} %s not found", key)
		return nil, errors.New("{{ .Name }} not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreate{{ initialCap .Name }}(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGet{{ initialCap .Name }}: %+v", vars)

	var obj {{ initialCap .Name }}
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding {{ .Name }} create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = Create{{ initialCap .Name }}(&obj)
	if err != nil {
		log.Errorf("Create{{ initialCap .Name }} error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDelete{{ initialCap .Name }}(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDelete{{ initialCap .Name }}: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := Delete{{ initialCap .Name }}(key)
	if err != nil {
		log.Errorf("Delete{{ initialCap .Name }} error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a {{ .Name }} object
func Create{{ initialCap .Name }}(obj *{{ initialCap .Name }}) error {
	// Validate parameters
	err := Validate{{ initialCap .Name }}(obj)
	if err != nil {
		log.Errorf("Validate{{ initialCap .Name }} retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.{{ initialCap .Name }}Cb == nil {
		log.Errorf("No callback registered for {{ .Name }} object")
		return errors.New("Invalid object type")
	}

	saveObj := obj

  collections.{{ .Name }}Mutex.Lock()
  key := collections.{{ .Name }}s[obj.Key]
  collections.{{ .Name }}Mutex.Unlock()

	// Check if object already exists
	if key != nil {
		// Perform Update callback
		err = objCallbackHandler.{{ initialCap .Name }}Cb.{{ initialCap .Name }}Update(collections.{{ .Name }}s[obj.Key], obj)
		if err != nil {
			log.Errorf("{{ initialCap .Name }}Update retruned error for: %+v. Err: %v", obj, err)
			return err
		}

		// save the original object after update
    collections.{{ .Name }}Mutex.Lock()
		saveObj = collections.{{ .Name }}s[obj.Key]
    collections.{{ .Name }}Mutex.Unlock()
	} else {
		// save it in cache
    collections.{{ .Name }}Mutex.Lock()
		collections.{{ .Name }}s[obj.Key] = obj
    collections.{{ .Name }}Mutex.Unlock()

		// Perform Create callback
		err = objCallbackHandler.{{ initialCap .Name }}Cb.{{ initialCap .Name }}Create(obj)
		if err != nil {
			log.Errorf("{{ initialCap .Name }}Create retruned error for: %+v. Err: %v", obj, err)
      collections.{{ .Name }}Mutex.Lock()
			delete(collections.{{ .Name }}s, obj.Key)
      collections.{{ .Name }}Mutex.Unlock()
			return err
		}
	}

	// Write it to modeldb
  collections.{{ .Name }}Mutex.Lock()
	err = saveObj.Write()
  collections.{{ .Name }}Mutex.Unlock()
	if err != nil {
		log.Errorf("Error saving {{ .Name }} %s to db. Err: %v", saveObj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to {{ .Name }} from collection
func Find{{ initialCap .Name }}(key string) *{{ initialCap .Name }} {
  collections.{{ .Name }}Mutex.Lock()
  defer collections.{{ .Name }}Mutex.Unlock()

	obj := collections.{{ .Name }}s[key]
	if obj == nil {
		return nil
	}

	return obj
}

// Delete a {{ .Name }} object
func Delete{{ initialCap .Name }}(key string) error {
  collections.{{ .Name }}Mutex.Lock()
	obj := collections.{{ .Name }}s[key]
  collections.{{ .Name }}Mutex.Unlock()
	if obj == nil {
		log.Errorf("{{ .Name }} %s not found", key)
		return errors.New("{{ .Name }} not found")
	}

	// Check if we handle this object
	if objCallbackHandler.{{ initialCap .Name }}Cb == nil {
		log.Errorf("No callback registered for {{ .Name }} object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.{{ initialCap .Name }}Cb.{{ initialCap .Name }}Delete(obj)
	if err != nil {
		log.Errorf("{{ initialCap .Name }}Delete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
  collections.{{ .Name }}Mutex.Lock()
	err = obj.Delete()
  collections.{{ .Name }}Mutex.Unlock()
	if err != nil {
		log.Errorf("Error deleting {{ .Name }} %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
  collections.{{ .Name }}Mutex.Lock()
	delete(collections.{{ .Name }}s, key)
  collections.{{ .Name }}Mutex.Unlock()

	return nil
}

func (self *{{ initialCap .Name }}) GetType() string {
	return "{{ .Name }}"
}

func (self *{{ initialCap .Name }}) GetKey() string {
	return self.Key
}

func (self *{{ initialCap .Name }}) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read {{ .Name }} object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("{{ .Name }}", self.Key, self)
}

func (self *{{ initialCap .Name }}) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write {{ .Name }} object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("{{ .Name }}", self.Key, self)
}

func (self *{{ initialCap .Name }}) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete {{ .Name }} object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("{{ .Name }}", self.Key)
}

func restore{{ initialCap .Name }}() error {
  collections.{{ .Name }}Mutex.Lock()
  defer collections.{{ .Name }}Mutex.Unlock()

	strList, err := modeldb.ReadAllObj("{{ .Name }}")
	if err != nil {
		log.Errorf("Error reading {{ .Name }} list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var {{ .Name }} {{ initialCap .Name }}
		err = json.Unmarshal([]byte(objStr), &{{ .Name }})
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.{{ .Name }}s[{{ .Name }}.Key] = &{{ .Name }}
	}

	return nil
}

// Validate a {{.Name}} object
func Validate{{initialCap .Name}}(obj *{{initialCap .Name}}) error {
  collections.{{ .Name }}Mutex.Lock()
  defer collections.{{ .Name }}Mutex.Unlock()

	// Validate key is correct
	keyStr := {{range $index, $element := .Key}}{{if eq 0 $index }}obj.{{initialCap .}} {{else}}+ ":" + obj.{{initialCap .}} {{end}}{{end}}
	if obj.Key != keyStr {
		log.Errorf("Expecting {{initialCap .Name}} Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field
	{{range $element := .CfgProperties}}{{if eq $element.Type "int"}}{{if ne $element.Default ""}}
	if obj.{{initialCap $element.Name}} == 0 {
		obj.{{initialCap $element.Name}} = {{$element.Default}}
	}
{{end}} {{if ne $element.Min 0.0}}
	if obj.{{initialCap $element.Name}} < {{$element.Min}} {
		return errors.New("{{$element.Name}} Value Out of bound")
	}
{{end}} {{if ne $element.Max 0.0}}
	if obj.{{initialCap $element.Name}} > {{$element.Max}} {
		return errors.New("{{$element.Name}} Value Out of bound")
	}
{{end}} {{else if eq $element.Type "number"}} {{if ne $element.Default ""}}
	if obj.{{initialCap $element.Name}} == 0 {
		obj.{{$element.Name}} = {{$element.Default}}
	}
{{end}} {{if ne $element.Min 0.0}}
	if obj.{{initialCap $element.Name}} < {{$element.Min}} {
		return errors.New("{{$element.Name}} Value Out of bound")
	}
{{end}} {{if ne $element.Max 0.0}}
	if obj.{{initialCap $element.Name}} > {{$element.Max}} {
		return errors.New("{{$element.Name}} Value Out of bound")
	}
{{end}} {{else if eq $element.Type "bool"}} {{if ne $element.Default ""}}
	if obj.{{initialCap $element.Name}} == false {
		obj.{{initialCap $element.Name}} = {{$element.Default}}
	}
{{end}} {{else if eq $element.Type "string"}} {{if ne $element.Default ""}}
	if obj.{{initialCap $element.Name}} == "" {
		obj.{{initialCap $element.Name}} = "{{$element.Default}}"
	}
{{end}} {{if ne $element.Length 0}}
	if len(obj.{{initialCap $element.Name}}) > {{$element.Length}} {
		return errors.New("{{$element.Name}} string too long")
	}
{{end}} {{if ne $element.Format ""}}
	{{$element.Name}}Match := regexp.MustCompile("{{$element.Format}}")
	if {{$element.Name}}Match.MatchString(obj.{{initialCap $element.Name}}) == false {
		return errors.New("{{$element.Name}} string invalid format")
	}
{{end}} {{end}} {{end}}

	return nil
}
{{ end }}

{{ end }}

  `,
}
