// {{.Name}}Client.go
// This file is auto generated by modelgen tool
// Do not edit this file manually

// package client provides contiv REST client implementation.
//
// Concepts and Terminology:
//
// Tenant : 
// Tenants provides namespace isolation for networks. It is the toplevel object where networks
// and policies are defiend. 
// A tenant can have many networks, each with its own subnet address, among other information. 
// A user can create networks with arbtrary subnet addresses within a tenant namespace, 
// possibly reusing subnet IP addresses in other tenants. This provides complete freedom to a 
// tenant user to specify the network names and their subnets within a tenant.
//
// Network:
// Network is an IPv4 or IPv6 subnet that may be provided with a default gateway. 
// For example, a network can map to a subnet 10.1.1.0/24 that has a default gateway of 10.1.1.1.
//
// Policies:
// A policy describes an operational behavior on a group of containers. 
// The operational behavior can be enforcement, allocation, prioritation, traffic redirection, 
// stats collection, or other action on the group on which the policy is applied. For example, 
// an inbound security policy on a database tier can specify the allowed ports on the containers 
// belonging to the group.
// 
// EndpointGroups:
// Endpoint group (or an application group) identifies a policy domain for a container or a pod. 
// The grouping is an arbitrary collection of containers that share a specific application domain, 
// for example all production,frontend containers, or backup,long-running containers. 
// This association is often done by specifying label in kubernetes pod spec
//
// contiv object model is shown here https://github.com/contiv/modelgen/blob/master/docs/contivModel.png
//
// Example:
//
//package main
//
//import (
//    "log"
//    "github.com/contiv/contivModel/client"
//)
//
//func main() {
//    cl, err := client.NewContivClient("localhost:9999")
//    if err != nil {
//        log.Fatal(err)
//    }
//
//    // Define a policy
//    policy := client.Policy{
//        TenantName: "tenant1",
//        PolicyName: "policy",
//    }
//
//    // Create policy
//    err = cl.PostPolicy(policy)
//    if err != nil {
//        log.Errorf("Policy Creation failed. Err: %v", err)
//    }
//}
package client

import (
	"bytes"
	"encoding/json"
	"errors"
	"io/ioutil"
	"net/http"

	log "github.com/Sirupsen/logrus"
)

// Link is a one way relattion between two objects
type Link struct {
	ObjType string `json:"type,omitempty"`
	ObjKey  string `json:"key,omitempty"`
}

func httpGet(url string, jdata interface{}) error {

	r, err := http.Get(url)
	if err != nil {
		return err
	}
	defer r.Body.Close()

	switch {
	case r.StatusCode == int(404):
		return errors.New("Page not found!")
	case r.StatusCode == int(403):
		return errors.New("Access denied!")
	case r.StatusCode == int(500):
		response, err := ioutil.ReadAll(r.Body)
		if err != nil {
			return err
		}

		return errors.New(string(response))

	case r.StatusCode != int(200):
		log.Debugf("GET Status '%s' status code %d \n", r.Status, r.StatusCode)
		return errors.New(r.Status)
	}

	response, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return err
	}

	if err := json.Unmarshal(response, jdata); err != nil {
		return err
	}

	return nil
}

func httpDelete(url string) error {

	req, err := http.NewRequest("DELETE", url, nil)

	r, err := http.DefaultClient.Do(req)
	if err != nil {
		panic(err)
	}
	defer r.Body.Close()

	// body, _ := ioutil.ReadAll(r.Body)

	switch {
	case r.StatusCode == int(404):
		// return errors.New("Page not found!")
		return nil
	case r.StatusCode == int(403):
		return errors.New("Access denied!")
	case r.StatusCode == int(500):
		response, err := ioutil.ReadAll(r.Body)
		if err != nil {
			return err
		}

		return errors.New(string(response))

	case r.StatusCode != int(200):
		log.Debugf("DELETE Status '%s' status code %d \n", r.Status, r.StatusCode)
		return errors.New(r.Status)
	}

	return nil
}

func httpPost(url string, jdata interface{}) error {
	buf, err := json.Marshal(jdata)
	if err != nil {
		return err
	}

	body := bytes.NewBuffer(buf)
	r, err := http.Post(url, "application/json", body)
	if err != nil {
		return err
	}
	defer r.Body.Close()

	switch {
	case r.StatusCode == int(404):
		return errors.New("Page not found!")
	case r.StatusCode == int(403):
		return errors.New("Access denied!")
	case r.StatusCode == int(500):
		response, err := ioutil.ReadAll(r.Body)
		if err != nil {
			return err
		}

		return errors.New(string(response))

	case r.StatusCode != int(200):
		log.Debugf("POST Status '%s' status code %d \n", r.Status, r.StatusCode)
		return errors.New(r.Status)
	}

	response, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return err
	}
	log.Debugf(string(response))

	return nil
}

// ContivClient has the contiv model client instance
type ContivClient struct {
	baseURL string
}

// NewContivClient creates a new client instance
func NewContivClient(baseURL string) (*ContivClient, error) {
	client := ContivClient{
		baseURL: baseURL,
	}

	return &client, nil
}
